Line 6: IndentationError: expected an indented block
在编译时会出现这样的错IndentationError:expected an indented block说明此处需要缩进，你只要在出现错误的那一行，按空格或Tab（但不能混用）键缩进就行。

>> 和 <<都是位运算，对二进制数进行移位操作。
<< 是左移，末位补0，类比十进制数在末尾添0相当于原数乘以10，x<<1是将x的二进制表示左移一位，相当于原数x乘2。比如整数4在二进制下是100，4<<1左移1位变成1000(二进制)，结果是8。
>>是右移，右移1位相当于除以2。
而>>=和<<=，就是对变量进行位运算移位之后的结果再赋值给原来的变量，可以类比赋值运算符+=和-=可以理解。
比如x>>=2， 就是把变量x右移2位，再保留x操作后的值。

如果要计算13^17，则计算方法如下：位运算相同为0不同为1，位运算可用于检验两个集合元素是否一样，详情见2020_03_02.py

01101 <====13
10001 <====17
---------
11100 ====>28

若13^13 ===》0
则
01101 <====13
01101 <====13
---------
00000 ====>0

python中没有字符之间的直接相减运算，但可以通过ord()函数实现
ord()函数主要用来返回对应字符的ascii码
>>> ord('9')-ord('0')
9
字符相减得到数字要用ord（）不然会报错

位运算符 	说明
<< 	按位左移，左移n位相当于乘以2的n次方
>> 	按位右移 ，左移n位相当于除以2的n次方
& 	按位与，二进制位数同且为1结果位为1
l 	按位或 ，二进制位数或有1结果位为1
^ 	按位异或 ，二进制位数不同结果位为1
~ 	按位取反，二进制位0和1结果位互换
————————————————

str = ‘0123456789’
print str[0:3] #截取第一位到第三位的字符
print str[:] #截取字符串的全部字符
print str[6:] #截取第七个字符到结尾
print str[:-3] #截取从头开始到倒数第三个字符之前
print str[2] #截取第三个字符
print str[-1] #截取倒数第一个字符
print str[::-1] #创造一个与原字符串顺序相反的字符串
print str[-3:-1] #截取倒数第三位与倒数第一位之前的字符
print str[-3:] #截取倒数第三位到结尾
print str[:-5:-3] #逆序截取，具体啥意思没搞明白？

str = "this is string example....wow!!! this is really string";
print str.replace("is", "was");
print str.replace("is", "was", 3);

thwas was string example....wow!!! thwas was really string
thwas was string example....wow!!! thwas is really string

python 从后往前面遍历
 for j in range(len(second)-1, -1, -1):
 
 关于2020_03_05.py 这道题是中等题，一开始以为很容易，没有想到不能开拓新空间只能在原有的数组上改，这是一个难点
 给定一幅由N × N矩阵表示的图像，其中每个像素的大小为4字节，编写一种方法，将图像旋转90度。
不占用额外内存空间能否做到？做到了哈哈哈哈

python常用函数
sorted（）排序时用到

>>>a = [5,7,6,3,4,1,2]
>>> b = sorted(a)       # 保留原列表
>>> a 
[5, 7, 6, 3, 4, 1, 2]
>>> b
[1, 2, 3, 4, 5, 6, 7]
 
>>> L=[('b',2),('a',1),('c',3),('d',4)]
>>> sorted(L, cmp=lambda x,y:cmp(x[1],y[1]))   # 利用cmp函数
[('a', 1), ('b', 2), ('c', 3), ('d', 4)]
>>> sorted(L, key=lambda x:x[1])               # 利用key
[('a', 1), ('b', 2), ('c', 3), ('d', 4)]
 
 
>>> students = [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
>>> sorted(students, key=lambda s: s[2])            # 按年龄排序
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
 
>>> sorted(students, key=lambda s: s[2], reverse=True)       # 按降序
[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
>>>

reversed()
reversed(seq)，seq -- 要转换的序列，可以是 tuple, string, list 或 range。

#!/usr/bin/env python3
 
# 字符串
seqString = 'Runoob'
print(list(reversed(seqString)))
 
# 元组
seqTuple = ('R', 'u', 'n', 'o', 'o', 'b')
print(list(reversed(seqTuple)))
 
# range
seqRange = range(5, 9)
print(list(reversed(seqRange)))
 
# 列表
seqList = [1, 2, 4, 3, 5]
print(list(reversed(seqList)))

以上实例输出结果为：

['b', 'o', 'o', 'n', 'u', 'R']
['b', 'o', 'o', 'n', 'u', 'R']
[8, 7, 6, 5]
[5, 3, 4, 2, 1]

python判断字符串（string）是否包含（contains）子字符串的方法
方法1：使用 in 方法实现contains的功能：
site = 'http://www.outofmemory.cn/'
if "sharejs"  in site:
     print('site contains sharejs') 
     
方法2：使用find函数实现contains的功能
s = "This be a string"
if s.find("is") == -1:
    print "No 'is' here!"
else:
    print "Found 'is' in the string."

reversed 函数返回一个反转的迭代器。
记得在reversed前面加list，eg：list(reversed(seqString))
不加的话返回的不是数列而是地址类的东西
seqString = 'Runoob'
print(list(reversed(seqString)))
 
# 元组
seqTuple = ('R', 'u', 'n', 'o', 'o', 'b')
print(list(reversed(seqTuple)))
 
# range
seqRange = range(5, 9)
print(list(reversed(seqRange)))
 
# 列表
seqList = [1, 2, 4, 3, 5]
print(list(reversed(seqList)))


 //弗洛伊德环
//注意fast走的路是slow的二倍，
// 1->3->4->5
//       |  |
//       7<-6  会在6遇到，1->4两个指针都会走1遍，4->6,fast会走两遍,slow走1遍，所以4->6这里fast是slow的二倍已经很明显了,
//剩下的路途，fast也要是slow的二倍，那么只能是fast的6->4 + 1->3 是slow的1->3的2倍，所以6->4应该等于1->3，所以只要让slow再走那么多就好了
//可以想象是一个环状的管子，向里面赛丝带

栈

存储局部变量
先压栈（进栈），然后弹栈（出栈）
先进后出原则，第一个进的最后一个出
方法执行完之后弹栈然后局部变量就没了
堆

存储成员变量
存储new出来的数组或者对象
先进先出原则
方法执行完之后，堆中的数组或者对象的内存中的成员变量就会成为垃圾，然后等待jvm的垃圾回收机制回收。
————————————————

